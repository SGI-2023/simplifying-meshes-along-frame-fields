#pragma once

#include <igl/opengl/glfw/Viewer.h>
#include <igl/read_triangle_mesh.h>
#include <igl/decimate.h>
#include <igl/principal_curvature.h>
#include <igl/flip_edge.h>
#include <set>

#include "utils.h"

struct Mesh
{
public:
    MatrixXd V;
    MatrixXi F;
    MatrixXd PD1, PD2;     // V * 3      Where V is the number of the Vertices
    VectorXd PV1, PV2;     // V          Where V is the number of the Vertices
    std::set<int> V2Fe;    // adjacent faces to vertices
    VectorXd A;            // frame field alignment vertex-based cost vector
    VectorXd AE;           // frame field alignment edge-based cost vector

    int v1, v2; 
    bool started = false;
    igl::decimate_pre_collapse_callback custom_pre_collapse_callback;
    igl::decimate_post_collapse_callback custom_post_collapse_callback;
    igl::decimate_stopping_condition_callback stopping_condition_callback;
    igl::decimate_cost_and_placement_callback cost_and_placement_callback;

    Mesh(std::string filename)
    {
        igl::read_triangle_mesh(filename, V, F);
        get_frame_field();
        initialize_decimation_callbacks();
    };

    void initialize_decimation_callbacks();
    void decimate();
    void get_frame_field();
    void frame_field_alignment_data();
    // Cost function based on frame-field alignment
    double frame_field_alignment_data(const int e, const MatrixXi &E);
    // Get frame field alignment edges
    void frame_field_alignment_data(const MatrixXi &E);

    // qcoarsen_based_cost and its helper functions 
    void compute_before(const int e,
                        const Eigen::MatrixXd &V,
                        const Eigen::MatrixXi &E,
                        const Eigen::MatrixXi &F,
                        const Eigen::VectorXi &EMAP,
                        const Eigen::MatrixXi &EF,
                        const Eigen::MatrixXi &EI,
                        int &valenceSum,
                        double &alignment,
                        std::vector<int> &neighbors);

    void compute_after(
        const Eigen::MatrixXd &V,
        const std::vector<int> &neighbors, // as generated by compute_before
        const Eigen::RowVector3d &p,      // new point
        int &valenceSum,
        double &alignment);

    void qcoarsen_based_cost(
        const int e,
        const Eigen::MatrixXd &V,
        const Eigen::MatrixXi &E,
        const Eigen::MatrixXi &F,
        const Eigen::VectorXi &EMAP,
        const Eigen::MatrixXi &EF,
        const Eigen::MatrixXi &EI,
        const Eigen::RowVector3d &p,
        double &cost);
};